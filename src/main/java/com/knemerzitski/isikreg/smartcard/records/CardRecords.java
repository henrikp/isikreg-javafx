package com.knemerzitski.isikreg.smartcard.records;import com.knemerzitski.isikreg.date.Date;import com.knemerzitski.isikreg.gson.GsonDateProperty;import com.knemerzitski.isikreg.settings.ColumnProperties;import com.knemerzitski.isikreg.settings.Settings;import com.knemerzitski.isikreg.settings.columns.Column;import com.knemerzitski.isikreg.settings.columns.OptionsColumn;import com.knemerzitski.isikreg.smartcard.APDUException;import com.knemerzitski.isikreg.utils.ByteUtils;import javafx.beans.property.Property;import javafx.beans.property.StringProperty;import javax.smartcardio.Card;import javax.smartcardio.CardChannel;import javax.smartcardio.CardException;import java.io.UnsupportedEncodingException;import java.nio.charset.Charset;import java.time.LocalDate;import java.util.*;import java.util.function.Supplier;import java.util.stream.Collectors;public abstract class CardRecords {  public static CardRecords read(Settings settings, HashMap<Class<? extends CardRecords>, Map<Column, Supplier<Record<?>>>> cardRecordsFactories, Card card) throws APDUException, UnsupportedEncodingException, CardException {    byte[] atrBytes = card.getATR().getBytes();    System.out.println("Card ATR: " + ByteUtils.toHexString(atrBytes));    if (EstIdCardRecordsV2018.isValidProtocol(atrBytes)) {      return new EstIdCardRecordsV2018(settings, cardRecordsFactories.get(EstIdCardRecordsV2018.class), card.getBasicChannel());    } else {      return new EstIdCardRecordsV2011(settings, cardRecordsFactories.get(EstIdCardRecordsV2011.class), card.getBasicChannel());    }  }  private final Settings settings;  // Used to store personal data file records. Total possible amount of records is 16.  private final Map<Column, Record<?>> recordsMap;  private final Map<Column.Id, Record<?>> recordsMapById;  public CardRecords(Settings settings, Map<Column, Supplier<Record<?>>> recordsFactory, CardChannel channel) throws CardException, APDUException, UnsupportedEncodingException {    this.settings = settings;    System.out.println("Using Protocol " + getClass().getSimpleName());    beforeReadRecords(channel);    // Read personal data file contents into array    recordsMap = recordsFactory.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue().get()));    recordsMapById = recordsMap.entrySet().stream().collect(Collectors.toMap(e -> e.getKey().id, Map.Entry::getValue));    List<RecordReader> recordReaders = recordsMap.values().stream()        .map(Record::getRecordReader).collect(Collectors.toList());    List<Byte> recordIndices = recordReaders.stream()        .flatMap(r -> Arrays.stream(r.getRecordNumbers()))        .distinct().collect(Collectors.toList());    String[] records = new String[16];    for (Byte i : recordIndices)      records[i - 1] = new String(readRecord(channel, i), getCardEncoding()).trim();    recordReaders.forEach(r -> r.readRecord(records));  }  protected abstract void beforeReadRecords(CardChannel channel) throws CardException, APDUException;  /**   * Read a record from the card using the given channel.   */  protected abstract byte[] readRecord(CardChannel channel, byte recordNumber) throws CardException, APDUException;  protected abstract Charset getCardEncoding();  public Map<Column, Record<?>> getRecordsMap() {    return recordsMap;  }  public ColumnProperties getColumnProperties() {    ColumnProperties properties = new ColumnProperties(settings);    recordsMap.forEach((column, record) -> {      Property<?> property = settings.newProperty(column);      properties.put(column, property);      Object value = record.get();      if (value instanceof LocalDate && property instanceof GsonDateProperty) {        GsonDateProperty dateProperty = (GsonDateProperty) property;        LocalDate dateRecord = (LocalDate) value;        dateProperty.set(new Date(dateRecord));      } else if (value instanceof String && property instanceof StringProperty) {        StringProperty stringProperty = (StringProperty) property;        String strRecord = (String) value;        if (column instanceof OptionsColumn) {          // Check within options id or label          OptionsColumn columnOptions = (OptionsColumn) column;          Optional<OptionsColumn.Option> optionalOption = columnOptions.options.stream()              .filter(o -> (o.id != null && o.id.toLowerCase().startsWith(strRecord.toLowerCase()))                  || o.label.toLowerCase().startsWith(strRecord.toLowerCase())).findFirst();          if (optionalOption.isPresent()) {            OptionsColumn.Option option = optionalOption.get();            stringProperty.set(option.label);          }        } else {          stringProperty.set(strRecord);        }      }    });    return properties;  }  public Map<Column.Id, Record<?>> getRecordsMapById() {    return recordsMapById;  }  public Object getRecordValue(Column column) {    Record<?> record = recordsMap.get(column);    return record != null ? record.get() : null;  }  public String getStringRecord(Column.Id id) {    Record<?> record = recordsMapById.get(id);    return getStringRecord(record);  }  public LocalDate getDateRecord(Column.Id id) {    Record<?> record = recordsMapById.get(id);    return getDateRecord(record);  }  public String getStringRecord(Column column) {    Record<?> record = recordsMap.get(column);    return getStringRecord(record);  }  public LocalDate getDateRecord(Column column) {    Record<?> record = recordsMap.get(column);    return getDateRecord(record);  }  private String getStringRecord(Record<?> record) {    if (record == null)      return null;    Object value = record.get();    if (value instanceof String)      return (String) value;    return null;  }  private LocalDate getDateRecord(Record<?> record) {    if (record == null)      return null;    Object value = record.get();    if (value instanceof LocalDate)      return (LocalDate) value;    return null;  }  public String getLastName() {    return getStringRecord(Column.Id.LAST_NAME);  }  public String getFirstName() {    return getStringRecord(Column.Id.FIRST_NAME);  }  public String getPersonalCode() {    return getStringRecord(Column.Id.PERSONAL_CODE);  }  public LocalDate getExpiryDate() {    return getDateRecord(Column.Id.EXPIRY_DATE);  }  @Override  public String toString() {    return this.getClass().getSimpleName() + "[" + recordsMap.entrySet().stream()        .map(e -> e.getKey().id.toString() + ": " + e.getValue().get())        .collect(Collectors.joining(", ")) + "]";  }}